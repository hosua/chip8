9c9
< 	this->opcode = mem[pc] << 8 | mem[pc + 1];
---
> 	this->opcode = mem[this->pc] << 8 | mem[this->pc + 1];
12c12
< 	pc += 2; // increment program counter
---
> 	this->pc += 2; // increment program counter
17,19c17,18
< 	if (dt){
< 		clock->wait(dt); // Wait for ticks to process
< 		dt = 0x0; // set dt to 0
---
> 	while (this->dt){
> 		
20a20,24
> 	if (this->dt){
> 		clock->wait(this->dt); // Wait for ticks to process
> 		this->dt = 0x0; // set dt to 0
> 	}
> 	clock->wait(1);
152c156
< 	if (VERBOSE_CPU) printf("0x%04x: 0x%04x ", pc, opcode);
---
> 	if (VERBOSE_CPU) printf("0x%04x: 0x%04x ", this->pc, opcode);
161c165
< 					v[x] += kk;
---
> 					this->v[x] += kk;
165,166c169,170
< 					v[y] += v[x]; 
< 					if (VERBOSE_CPU) printf("V%i V%i\n", v[x], v[y]);
---
> 					this->v[y] += this->v[x]; 
> 					if (VERBOSE_CPU) printf("V%i V%i\n", this->v[x], this->v[y]);
169c173
< 					this->i += v[x];
---
> 					this->i += this->v[x];
178c182
< 			printf("V%zu &= V%zu\n", x, y);
---
> 			printf("V%zu & V%zu\n", x, y);
181,184c185,188
< 		case Op::CALL: // 2nnn - Call subroutine
< 			this->stack.push(pc);
< 			pc = nnn; // Store address into program counter
< 			pc -= 2;
---
> 		case Op::CALL: // Call subroutine
> 			this->stack.push(this->pc);
> 			this->pc = nnn; // Store address into program counter
> 			this->pc -= 2;
186c190
< 		case Op::CLS: // 00E0 - Clear screen
---
> 		case Op::CLS: // Clear screen
193c197,214
< 		case Op::DRW: // Dxyn - Draw
---
> 		case Op::JP: // Jump
> 			switch(opcode & 0xF000){
> 				default:
> 					if (VERBOSE_CPU) printf("\nError: Invalid opcode {%04x}\n", opcode);
> 					break;
> 				case 0x1000: // 1nnn - jump to address nnn
> 					this->pc = nnn;
> 					if (VERBOSE_CPU) printf("0x%03x\n", nnn);
> 					this->pc -= 2;
> 					break;
> 				case 0xB000: // Bnnn - jump to address nnn + v[0]
> 					this->pc = nnn + v[0];
> 					if (VERBOSE_CPU) printf("0x%03x + 0x%03x\n", v[0], nnn);
> 					this->pc -= 2;
> 					break;
> 			}
> 			break;
> 		case Op::DRW:
195c216
< 				if (VERBOSE_CPU) printf("Vx: 0x%01x Vy: 0x%01x n: %i i: 0x%02x\n", v[x], v[y], n, this->i);
---
> 				if (VERBOSE_CPU) printf("Vx: 0x%01x Vy: 0x%01x n: %i i: 0x%02x\n", this->v[x], this->v[y], n, this->i);
204c225
< 				v[0xF] = 0;
---
> 				this->v[0xF] = 0;
211c232
< 					px = mem[this->i + dy];
---
> 					px = this->mem[this->i + dy];
216c237
< 							if(chip8->gfx[(v[x] + dx + ((v[y] + dy) * DISP_X))]){
---
> 							if(chip8->gfx[(this->v[x] + dx + ((this->v[y] + dy) * DISP_X))]){
218c239
< 								v[0xF] = 1;
---
> 								this->v[0xF] = 1;
220c241
< 							chip8->gfx[v[x] + dx + ((v[y] + dy) * DISP_X)] ^= 1;
---
> 							chip8->gfx[this->v[x] + dx + ((this->v[y] + dy) * DISP_X)] ^= 1;
228,244d248
< 		case Op::JP: // 1nnn, Bnnn Jump
< 			switch(opcode & 0xF000){
< 				default:
< 					if (VERBOSE_CPU) printf("\nError: Invalid opcode {%04x}\n", opcode);
< 					break;
< 				case 0x1000: // 1nnn - jump to address nnn
< 					pc = nnn;
< 					if (VERBOSE_CPU) printf("0x%03x\n", nnn);
< 					pc -= 2;
< 					break;
< 				case 0xB000: // Bnnn - jump to address nnn + v[0]
< 					pc = nnn + v[0];
< 					if (VERBOSE_CPU) printf("0x%03x + 0x%03x\n", v[0], nnn);
< 					pc -= 2;
< 					break;
< 			}
< 			break;
252c256
< 						v[x] = kk;
---
> 						this->v[x] = kk;
254c258
< 						// pc -= 2; // TODO: I don't know how this is right, but I fucking want to know why
---
> 						this->pc -= 2; // TODO: I don't know how this is right, but I fucking want to know why
257,258c261,262
< 						v[x] = v[y];
< 						if (VERBOSE_CPU) printf("V%i V%i\n", v[x], v[y]);
---
> 						this->v[x] = this->v[y];
> 						if (VERBOSE_CPU) printf("V%i V%i\n", this->v[x], this->v[y]);
270c274
< 								dt = v[x];
---
> 								this->dt = this->v[x];
276c280
< 									v[x] = InputHandler::WaitForKeyPress();
---
> 									this->v[x] = InputHandler::WaitForKeyPress();
280c284
< 								v[x] = dt;
---
> 								this->v[x] = this->dt;
284c288
< 								v[x] = this->st;
---
> 								this->v[x] = this->st;
290c294
< 								this->i = v[x] * 0x5; // Each font is 5 bytes wide (as shown in textfont) 
---
> 								this->i = this->v[x] * 0x5; // Each font is 5 bytes wide (as shown in textfont) 
296,298c300,302
< 								mem[this->i] = v[x] / 100; // Load 100s place into memory
< 								mem[this->i+1] = (v[x] / 10) % 10; // Load 10s place into memory
< 								mem[this->i+2] = v[x] % 10; // Load 1s place into memory
---
> 								this->mem[this->i] = this->v[x] / 100; // Load 100s place into memory
> 								this->mem[this->i+1] = (this->v[x] / 10) % 10; // Load 10s place into memory
> 								this->mem[this->i+2] = this->v[x] % 10; // Load 1s place into memory
305c309
< 									mem[this->i + i] = v[i];
---
> 									this->mem[this->i + i] = this->v[i];
313c317
< 									v[i] = mem[this->i + i];
---
> 									this->v[i] = this->mem[this->i + i];
321,325d324
< 		case Op::OR: // 8xy1 - OR Vx, Vy
< 			// Set Vx = Vx OR Vy.
< 			v[x] |= v[y];
< 			// Performs a bitwise OR on the values of Vx and Vy, then stores the result in Vx. 
< 			break;
328,329c327,328
< 			if (v[x] == kk){ 
< 				pc += 2;
---
> 			if (this->v[x] == kk){ 
> 				this->pc += 2;
331c330
< 				if (VERBOSE_CPU) printf("V%zu: 0x%02x == 0x%02x\n", x, v[x], kk);
---
> 				if (VERBOSE_CPU) printf("V%zu: 0x%02x == 0x%02x\n", x, this->v[x], kk);
334c333
< 				if (VERBOSE_CPU) printf("V%zu: 0x%02x != 0x%02x\n", x, v[x], kk);
---
> 				if (VERBOSE_CPU) printf("V%zu: 0x%02x != 0x%02x\n", x, this->v[x], kk);
340,341c339,340
< 				if (v[x] != kk){
< 					pc += 2;
---
> 				if (this->v[x] != kk){
> 					this->pc += 2;
343c342
< 					if (VERBOSE_CPU) printf("V%zu: 0x%02x != 0x%02x\n", x, v[x], kk);
---
> 					if (VERBOSE_CPU) printf("V%zu: 0x%02x != 0x%02x\n", x, this->v[x], kk);
346c345
< 					if (VERBOSE_CPU) printf("V%zu: 0x%02x == 0x%02x\n", x, v[x], kk);
---
> 					if (VERBOSE_CPU) printf("V%zu: 0x%02x == 0x%02x\n", x, this->v[x], kk);
350c349
< 		case Op::SHR: // 8xy6 - SHR Vx {, Vy} // "Shift right"
---
> 		case Op::SHR: // 8xy6 - SHR Vx {, Vy}
352d350
< 				// TODO: Wrong according to opcode test
354,357c352,364
< 				// Store LSB in vf
< 				v[0xF] = v[x] & 1;
< 				// Shift vy right once and store it in vx
< 				v[x] = v[y] >> 1;
---
> 				// If the least-significant bit of Vx is 1, 
> 				if (this->v[x] & 1){ 
> 					// then VF is set to 1, 
> 					this->v[0xF] = 1;
> 					if (VERBOSE_CPU) printf("V%zu & 1 == 1, V0x%01x = 1\n", x, 0xF);
> 				} else { 
> 					// otherwise 0. 
> 					this->v[0xF] = 0;
> 					if (VERBOSE_CPU) printf("V%zu & 1 != 1, V0x%01x = 0\n", x, 0xF);
> 				}
> 				// Then Vx is divided by 2.
> 				if (VERBOSE_CPU) printf("V%zu /= 2\n", x);
> 				this->v[x] /= 2;
363,364c370,371
< 				if (chip8->keys[v[x]]){ // If key is pressed
< 					pc += 2;
---
> 				if (chip8->keys[this->v[x]]){ // If key is pressed
> 					this->pc += 2;
375c382
< 				if (!chip8->keys[v[x]]){ // If key is not pressed
---
> 				if (!chip8->keys[this->v[x]]){ // If key is not pressed
377c384
< 					pc += 2;
---
> 					this->pc += 2;
384,409d390
< 		case Op::SUB: // 8xy5 - SUB Vx, Vy
< 			// If Vx > Vy, then VF is set to 1, otherwise 0. 
< 			if (v[x] > v[y]){
< 				if (VERBOSE_CPU) printf("Borrow occurred\n");
< 				v[0xF] = 1; 	
< 			} else {
< 				if (VERBOSE_CPU) printf("No borrow occurred\n");
< 				v[0xF] = 0;
< 			}
< 			// Set Vx = Vx - Vy, set VF = NOT borrow.
< 			// Then Vy is subtracted from Vx, and the results stored in Vx.
< 			v[x] -= v[y];
< 			if (VERBOSE_CPU) printf("V%zu -= V%zu\n", x, y);
< 			break;
< 		case Op::SUBN: // 8xy7 - SUBN Vx, Vy
< 			// Set Vx = Vy - Vx, set VF = NOT borrow.
< 			// If Vy > Vx, then VF is set to 1, otherwise 0. 
< 			if (v[y] > v[x]){
< 				v[0xF] = 1;
< 			} else {
< 				v[0xF] = 0;
< 			}
< 			// Then Vx is subtracted from Vy, and the results stored in Vx.
< 			v[x] = v[y] - v[x];
< 			if (VERBOSE_CPU) printf("Warning: op is not implemented yet!\n");
< 			break;
412c393
< 			pc = this->stack.top();
---
> 			this->pc = this->stack.top();
415,416c396,397
< 		case Op::RND: // RND Vx - "Random"
< 			v[x] = (rand() % 0xFF) & 0xFF; // Set Vx to random # from (0-255), then & 255
---
> 		case Op::RND: // RND Vx "Random"
> 			this->v[x] = (rand() % 0xFF) & 0xFF; // Set Vx to random # from (0-255), then & 255
424,425c405,406
< 			if (VERBOSE_CPU) printf("V%zu = Vx ^ Vy = 0x%02x\n", x, v[x] ^ v[y]);
< 			v[x] ^= v[y];
---
> 			if (VERBOSE_CPU) printf("V%zu = Vx ^ Vy = 0x%02x\n", x, this->v[x] ^ this->v[y]);
> 			this->v[x] ^= this->v[y];
437c418
< 		printf("%i: %02x ", i, v[i]);
---
> 		printf("%i: %02x ", i, this->v[i]);
441,442c422,423
< 	printf("pc: 0x%04x\n", pc);
< 	printf("dt: 0x%02x\n", dt);
---
> 	printf("pc: 0x%04x\n", this->pc);
> 	printf("dt: 0x%02x\n", this->dt);
